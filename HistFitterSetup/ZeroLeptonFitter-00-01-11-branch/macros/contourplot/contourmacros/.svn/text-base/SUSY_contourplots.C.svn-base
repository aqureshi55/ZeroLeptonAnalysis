#include "contourmacros/CombinationGlob.C"
#include "TColor.h"
#include <TStyle.h>
#include "TPave.h"

#include <TFile.h>
#include <TTree.h>
#include <Riostream.h>
#include "contourmacros/GG_direct_8TeVobs.C"
#include "contourmacros/SS_direct_8TeVobs.C"
#include "contourmacros/SS_onestepCC_8TeVobs.C"
#include "contourmacros/GG_onestepCCx12_8TeVobs.C"
#include "TROOT.h"
#include <algorithm>
#include <iostream>
#include <sstream>
#include "summary_harvest_tree_description.h"

const bool doSmooth=false;
TFile* outfile(0);

void initialize() {
   gSystem->Load("libSusyFitter.so");
}

TH2F* FixAndSetBorders( const TH2& hist, const char* name, const char* title, Double_t val );

TGraph* ContourGraph( TH2F* hist);

TH2F* linearsmooth(const TH2& hist, const char* name, const char* title);

void
DummyLegendExpected(TLegend* leg, TString what,  Int_t fillColor, Int_t fillStyle, Int_t lineColor, Int_t lineStyle, Int_t lineWidth)
{
  TGraph* gr = new TGraph();
  gr->SetFillColor(fillColor);
  gr->SetFillStyle(fillStyle);
  gr->SetLineColor(lineColor);
  gr->SetLineStyle(lineStyle);
  gr->SetLineWidth(lineWidth);
  leg->AddEntry(gr,what,"LF");
}

void
DummyLegendBestSR(TLegend* leg, TString what,  Int_t fillColor, Int_t fillStyle, Int_t lineColor, Int_t lineStyle, Int_t lineWidth)
{
  TGraph* gr = new TGraph();
  gr->SetFillColor(fillColor);
  gr->SetFillStyle(fillStyle);
  gr->SetLineColor(lineColor);
  gr->SetLineStyle(lineStyle);
  gr->SetLineWidth(lineWidth);
  leg->AddEntry(gr,what,"LF");
}

void
DummyLegendLine(TLegend* leg, TString what, Int_t lineColor, Int_t lineStyle, Int_t lineWidth)
{
  TGraph* gr = new TGraph();
  gr->SetFillColor(0);
  gr->SetFillStyle(0);
  gr->SetLineColor(lineColor);
  gr->SetLineStyle(lineStyle);
  gr->SetLineWidth(lineWidth);
  leg->AddEntry(gr,what,"L");
}

TGraph*
ContourGraph( TH2F* hist)
{

   std::cout<<" ContourGraph in SUSY_contorplots.C : hist address : "<<hist<<std::endl;
   TH2F* h = (TH2F*)hist->Clone();
   TCanvas* ctmp=new TCanvas("ctmp","ctmp",800,600);
   cout << "==> Will dumb histogram: " << h->GetName() << " into a graph" <<endl;
   //h->SetContour( 1 );
   h->SetContour( 2 );
   double pval = CombinationGlob::cl_percent[1];
   double signif = TMath::NormQuantile(1-pval);
   std::cout<<" contour : significance = "<<signif<<std::endl;
   h->SetContourLevel( 0, signif );
   h->SetContourLevel( 1, (signif<5)?5:99 );
   cout << "Draw contour histogram " << h->GetName() <<" : "<<h->GetEntries()<<endl;
   h->Draw("CONT LIST");
   h->SetDirectory(0);
   cout << "Canvas update"<<endl;
   ctmp->Update();
   TObjArray *contours(0);
   contours = (TObjArray*) gROOT->GetListOfSpecials()->FindObject("contours");
   if(!contours){
     std::cout<<"Error!! Failed to get contours from gROOT"<<std::endl;
     gROOT->ls();
     exit(1);
   }
   cout << "Retrieve contours as TGraph"<<endl;
   Int_t ncontours     = contours->GetSize();
   TList *list = (TList*)contours->At(0);
   Int_t number_of_lists = list->GetSize();
   cout << "Retrieve first graph of contour"<<endl;
   TGraph* gr(0);
   gr = (TGraph*)list->At(0)->Clone("gr");
   if(!gr){
     std::cout<<"Error!! Failed to get first graph of contour."<<std::endl;
     exit(1);
   }
   TGraph* grTmp;
   for (int k = 0 ; k<number_of_lists ; k++){
      cout << "Retrieve "<<k<<"th/"<<number_of_lists<<" graph of contour"<<endl;
      grTmp = 0;
      grTmp = (TGraph*)list->At(k)->Clone((TString)("grTmp"+std::to_string(k)) );
      if( !grTmp ){
        std::cout<<"Error!! Failed to get "<<k<<" graph of contour."<<std::endl;
        exit(1);
      }
      Int_t N = gr->GetN();
      Int_t N_tmp = grTmp->GetN();
      if(N < N_tmp){
        std::cout << "Set "<<k<<"th graph as contour."<<std::endl;
        gr = grTmp;
      }
      //
      //    mg->Add((TGraph*)list->At(k));
   }
   std::cout << "Finish retrieving graph of contour"<<std::endl;

   gr->SetName(hist->GetName());
   int N = gr->GetN();
   double x0, y0;

   //  for(int j=0; j<N; j++) {
   //    gr->GetPoint(j,x0,y0);
   //    cout << j << " : " << x0 << " : "<<y0 << endl;
   //  }
   //  //  gr->SetMarkerSize(2.0);
   //  gr->SetMarkerSize(2.0);
   //  gr->SetMarkerStyle(21);

   //  gr->Draw("LP");


   //  cout << "Generated graph " << gr << " with name " << gr->GetName() << endl;
   return gr;

}


  TGraph*
DrawExpectedBand( TGraph* gr1,  TGraph* gr2, Int_t fillColor, Int_t fillStyle, Int_t cut = 0 )
{

  //  TGraph* gr1 = new TGraph( *graph1 );
  //  TGraph* gr2 = new TGraph( *graph2 );

  int number_of_bins = max(gr1->GetN(),gr2->GetN());

  const Int_t gr1N = gr1->GetN();
  const Int_t gr2N = gr2->GetN();

  const Int_t N = number_of_bins;
  Double_t x1[N], y1[N], x2[N], y2[N];

  Double_t xx0, yy0;

  for(int j=0; j<gr1N; j++) {
    gr1->GetPoint(j,xx0,yy0);
    x1[j] = xx0;
    y1[j] = yy0;
  }
  if (gr1N < N) {
    for(int i=gr1N; i<N; i++) {
      x1[i] = x1[gr1N-1];
      y1[i] = y1[gr1N-1];
    }      
  }

  Double_t xx1, yy1;

  for(int j=0; j<gr2N; j++) {
    gr2->GetPoint(j,xx1,yy1);
    x2[j] = xx1;
    y2[j] = yy1;
  }
  if (gr2N < N) {
    for(int i=gr2N; i<N; i++) {
      x2[i] = x2[gr1N-1];
      y2[i] = y2[gr1N-1];
    }      
  }


  TGraph *grshade = new TGraphAsymmErrors(2*N);

  for (int i=0;i<N;i++) {
    if (x1[i] > cut)
      grshade->SetPoint(i,x1[i],y1[i]);
    if (x2[N-i-1] > cut)
      grshade->SetPoint(N+i,x2[N-i-1],y2[N-i-1]);
  }

  // Apply the cut in the shade plot if there is something that doesn't look good...
  int Nshade = grshade->GetN();
  double x0, y0;
  double x00, y00;

  for(int j=0; j<Nshade; j++) {
    grshade->GetPoint(j,x0,y0);
    if ((x0 != 0) && (y0 != 0)) {
      x00 = x0;
      y00 = y0;
      break;
    }
  }

  for(int j=0; j<Nshade; j++) {
    grshade->GetPoint(j,x0,y0);
    if ((x0 == 0) && (y0 == 0)) 
      grshade->SetPoint(j,x00,y00);
  }


  // Now draw the plot... 
  grshade->SetFillStyle(fillStyle);
  grshade->SetFillColor(fillColor);
  grshade->SetLineColor(fillColor);
  grshade->SetMarkerStyle(21);
  /*
     grshade->GetXaxis()->SetRangeUser(200.,2000.);
     grshade->GetXaxis()->SetLimits(200.,2000.);
     grshade->SetMinimum(0.);
     grshade->SetMaximum(1400.);
     */

  //grshade->Draw("FL same");
  grshade->Draw("FC same");

  return grshade;
}


  void
MirrorBorders( TH2& hist )
{
  int numx = hist.GetNbinsX();
  int numy = hist.GetNbinsY();

  Float_t val;
  // corner points
  hist.SetBinContent(0,0,hist.GetBinContent(1,1));
  hist.SetBinContent(numx+1,numy+1,hist.GetBinContent(numx,numy));
  hist.SetBinContent(numx+1,0,hist.GetBinContent(numx,1));
  hist.SetBinContent(0,numy+1,hist.GetBinContent(1,numy));

  for(int i=1; i<=numx; i++){
    hist.SetBinContent(i,0,	   hist.GetBinContent(i,1));
    hist.SetBinContent(i,numy+1, hist.GetBinContent(i,numy));
  }
  for(int i=1; i<=numy; i++) {
    hist.SetBinContent(0,i,      hist.GetBinContent(1,i));
    hist.SetBinContent(numx+1,i, hist.GetBinContent(numx,i));
  }
}


  TH2F*
AddBorders( const TH2& hist, const char* name=0, const char* title=0)
{
  int nbinsx = hist.GetNbinsX();
  int nbinsy = hist.GetNbinsY();

  double xbinwidth = ( hist.GetXaxis()->GetBinCenter(nbinsx) - hist.GetXaxis()->GetBinCenter(1) ) / double(nbinsx-1);
  double ybinwidth = ( hist.GetYaxis()->GetBinCenter(nbinsy) - hist.GetYaxis()->GetBinCenter(1) ) / double(nbinsy-1);

  double xmin = hist.GetXaxis()->GetBinCenter(0) - xbinwidth/2. ;
  double xmax = hist.GetXaxis()->GetBinCenter(nbinsx+1) + xbinwidth/2. ;
  double ymin = hist.GetYaxis()->GetBinCenter(0) - ybinwidth/2. ;
  double ymax = hist.GetYaxis()->GetBinCenter(nbinsy+1) + ybinwidth/2. ;

  TH2F* hist2 = new TH2F(name, title, nbinsx+2, xmin, xmax, nbinsy+2, ymin, ymax);

  for (Int_t ibin1=0; ibin1 <= hist.GetNbinsX()+1; ibin1++) {
    for (Int_t ibin2=0; ibin2 <= hist.GetNbinsY()+1; ibin2++)
      hist2->SetBinContent( ibin1+1, ibin2+1, hist.GetBinContent(ibin1,ibin2) );
  }

  return hist2;
}


void SetBorders( TH2 &hist, Double_t val=0 )
{
  int numx = hist.GetNbinsX();
  int numy = hist.GetNbinsY();

  for(int i=0; i <= numx+1 ; i++){
    hist.SetBinContent(i,0,val);
    hist.SetBinContent(i,numy+1,val);
  }
  for(int i=0; i <= numy+1 ; i++) {
    hist.SetBinContent(0,i,val);
    hist.SetBinContent(numx+1,i,val);
  }
}


  TH2F* 
FixAndSetBorders( const TH2& hist, const char* name=0, const char* title=0, Double_t val=0 )
{
  TH2F* hist0 = (TH2F*) hist.Clone(); // histogram we can modify

  MirrorBorders( *hist0 );    // mirror values of border bins into overflow bins

  TH2F* hist1 = AddBorders( *hist0, "hist1", "hist1" );   
  // add new border of bins around original histogram,
  // ... so 'overflow' bins become normal bins
  SetBorders( *hist1, val );                              
  // set overflow bins to value 1

  TH2F* histX = AddBorders( *hist1, "histX", "histX" );   
  // add new border of bins around original histogram,
  // ... so 'overflow' bins become normal bins

  TH2F* hist3 = (TH2F*)histX->Clone();
  hist3->SetName( name!=0 ? name : "hist3" );
  hist3->SetTitle( title!=0 ? title : "hist3" );

  delete hist0; delete hist1; delete histX;
  return hist3; // this can be used for filled contour histograms
}


  void 
DrawContourSameColor( TLegend *leg, TH2F* hist, Int_t nsigma, TString color, Bool_t second=kFALSE, TH2F* inverse=0, Bool_t linesOnly=kFALSE, Bool_t isnobs=kFALSE )
{
  if (nsigma < 1 || nsigma > 3) {
    cout << "*** Error in CombinationGlob::DrawContour: nsigma out of range: " << nsigma 
      << "==> abort" << endl;
    exit(1);
  }
  nsigma--; // used as array index

  Int_t lcol_sigma;
  Int_t fcol_sigma[3];

  if( color == "pink" ){
    lcol_sigma    = CombinationGlob::c_VDarkPink;
    fcol_sigma[0] = CombinationGlob::c_LightPink;
    fcol_sigma[1] = CombinationGlob::c_LightPink;
    fcol_sigma[2] = CombinationGlob::c_LightPink;
  }
  else if( color == "green" ){ // HF
    lcol_sigma    = CombinationGlob::c_VDarkGreen;
    fcol_sigma[0] = CombinationGlob::c_DarkGreen;
    fcol_sigma[1] = CombinationGlob::c_LightGreen;
    fcol_sigma[2] = CombinationGlob::c_VLightGreen;
  } 
  else if( color == "yellow" ){
    lcol_sigma    = CombinationGlob::c_VDarkYellow;
    fcol_sigma[0] = CombinationGlob::c_DarkYellow;
    fcol_sigma[1] = CombinationGlob::c_DarkYellow;
    fcol_sigma[2] = CombinationGlob::c_White; //c_DarkYellow;
  }
  else if( color == "orange" ){
    lcol_sigma    = CombinationGlob::c_VDarkOrange;
    fcol_sigma[0] = CombinationGlob::c_DarkOrange;
    fcol_sigma[1] = CombinationGlob::c_LightOrange; // c_DarkOrange
    fcol_sigma[2] = CombinationGlob::c_VLightOrange;
  }
  else if( color == "gray" ){
    lcol_sigma    = CombinationGlob::c_VDarkGray;
    fcol_sigma[0] = CombinationGlob::c_LightGray;
    fcol_sigma[1] = CombinationGlob::c_LightGray;
    fcol_sigma[2] = CombinationGlob::c_LightGray;
  }
  else if( color == "blue" ){
    lcol_sigma    = CombinationGlob::c_DarkBlueT1;
    fcol_sigma[0] = CombinationGlob::c_BlueT5;
    fcol_sigma[1] = CombinationGlob::c_BlueT3;
    fcol_sigma[2] = CombinationGlob::c_White;  //CombinationGlob::c_BlueT2;
  }

  // contour plot
  TH2F* h = new TH2F( *hist );
  h->SetContour( 1 );
  double pval = CombinationGlob::cl_percent[1];
  double signif = TMath::NormQuantile(1-pval);
  double dnsigma = double(nsigma)-1.;
  double dsignif = signif + dnsigma;
  h->SetContourLevel( 0, dsignif );

  if( !second ){
    h->SetFillColor( fcol_sigma[nsigma] );

    if (!linesOnly) h->Draw( "samecont0" );
  }

  /*  
  // inverse contours plot, needed in case of contours within contours
  if (inverse!=0) {
  TH2F* g = new TH2F( *inverse );
  g->SetContour( 1 );
  g->SetContourLevel( 0, CombinationGlob::cl_percent[nsigma] );
  if( !second ){
  g->SetFillColor( 0 );
  if (!linesOnly) g->Draw( "samecont0" );
  }
  }
  */

  h->SetLineColor( nsigma==1? 4 : lcol_sigma );
  if (isnobs)h->SetLineColor( nsigma==1? 1 : lcol_sigma );
  //h->SetLineStyle( 4 );
  h->SetLineWidth( 2 );
  h->Draw( "samecont3" );

  if (linesOnly&&!isnobs)
    if(nsigma==1){ leg->AddEntry(h,"expected 95% C.L. exclusion ","l");}
  if (isnobs)
    if(nsigma==1){ leg->AddEntry(h,"observed 95% C.L. exclusion","l");}  
  if (!linesOnly) {
    if(nsigma==0){ leg->AddEntry(h,"expected 68% C.L. exclusion","l"); }
    if(nsigma==2){ leg->AddEntry(h,"expected 99% C.L. exclusion","l");}
  }


}


  void 
DrawContourSameColorDisc( TLegend *leg, TH2F* hist, Double_t nsigma, TString color, Bool_t second=kFALSE, TH2F* inverse=0, Bool_t linesOnly=kFALSE )
{
  if (nsigma < 0.5 || nsigma > 10.5 ) {
    cout << "*** Error in CombinationGlob::DrawContour: nsigma out of range: " << nsigma 
      << "==> abort" << endl;
    exit(1);
  }

  Int_t lcol_sigma;
  Int_t fcol_sigma[3];

  if( color == "pink" ){
    lcol_sigma    = CombinationGlob::c_DarkPink;
    fcol_sigma[0] = CombinationGlob::c_VLightPink;
    fcol_sigma[1] = CombinationGlob::c_VLightPink;
    fcol_sigma[2] = CombinationGlob::c_VLightPink;
  }
  else if( color == "green" ){ // HF
    lcol_sigma    = CombinationGlob::c_VDarkGreen;
    fcol_sigma[0] = CombinationGlob::c_DarkGreen;
    fcol_sigma[1] = CombinationGlob::c_LightGreen;
    fcol_sigma[2] = CombinationGlob::c_VLightGreen;
  } 
  else if( color == "yellow" ){
    lcol_sigma    = CombinationGlob::c_VDarkYellow;
    fcol_sigma[0] = CombinationGlob::c_DarkYellow;
    fcol_sigma[1] = CombinationGlob::c_DarkYellow;
    fcol_sigma[2] = CombinationGlob::c_White; //c_DarkYellow;
  }
  else if( color == "orange" ){
    lcol_sigma    = CombinationGlob::c_VDarkOrange;
    fcol_sigma[0] = CombinationGlob::c_DarkOrange;
    fcol_sigma[1] = CombinationGlob::c_LightOrange; // c_DarkOrange
    fcol_sigma[2] = CombinationGlob::c_VLightOrange;
  }
  else if( color == "gray" ){
    lcol_sigma    = CombinationGlob::c_VDarkGray;
    fcol_sigma[0] = CombinationGlob::c_LightGray;
    fcol_sigma[1] = CombinationGlob::c_LightGray;
    fcol_sigma[2] = CombinationGlob::c_LightGray;
  }
  else if( color == "blue" ){
    lcol_sigma    = CombinationGlob::c_DarkBlueT1;
    fcol_sigma[0] = CombinationGlob::c_LightBlue;
    fcol_sigma[1] = CombinationGlob::c_LightBlue;
    fcol_sigma[2] = CombinationGlob::c_LightBlue;
  }

  // contour plot
  TH2F* h = new TH2F( *hist );
  h->SetContour( 1 );
  double dsignif = double (nsigma);
  h->SetContourLevel( 0, dsignif );

  //Int_t mycolor = (nsigma==3   ? 0 : 2);
  Int_t mycolor = (nsigma==2 ? 1 : 2);

  h->SetFillStyle(3003);

  if( !second ){
    h->SetFillColor( fcol_sigma[mycolor] );
    if (!linesOnly) h->Draw( "samecont0" );
  }

  h->SetLineColor( (nsigma==3) ? lcol_sigma : lcol_sigma );

  h->SetLineStyle( nsigma==3 || nsigma==2 ? 1 : 2 );
  h->SetLineWidth( nsigma==3 || nsigma==2 ? 2 : 1 );


  h->Draw( "samecont3" );

  if(nsigma==3)   { leg->AddEntry(h,"3 #sigma evidence","l"); }
  if(nsigma==6)   { leg->AddEntry(h,"N (int) #sigma","l"); }
  if(nsigma==2)   { leg->AddEntry(h,"2 #sigma evidence","l"); }
}




  void
DrawContourMassLine(TH2F* hist, Double_t mass, int color=14 )
{

  // contour plot
  TH2F* h = new TH2F( *hist );

  //  Double_t contours[5] = {500, 1000, 1500, 2000, 2500}
  h->SetContour( 1 );
  //h->SetContour( 5, contours )
  //  h->SetContourLevel( 0, contours );
  h->SetContourLevel( 0, mass );

  h->SetLineColor( color );
  h->SetLineStyle( 7 );
  h->SetLineWidth( 1 );
  h->Draw( "samecont3" );

}


void 
DrawContourLine95( TLegend *leg, TH2F* hist, const TString& text="", Int_t linecolor=CombinationGlob::c_VDarkGray, Int_t linestyle=2, Int_t linewidth=2 , TString Grid="" )
{

  // contour plot
  TH2F* h = new TH2F( *hist );
  h->SetContour( 1 );
  double pval = CombinationGlob::cl_percent[1];
  double signif = TMath::NormQuantile(1-pval);
  //cout << "signif: " <<signif << endl;
  h->SetContourLevel( 0, signif );

  h->SetLineColor( linecolor );
  h->SetLineWidth( linewidth );
  h->SetLineStyle( linestyle );
  h->Draw( "samecont3" );

  if (!text.IsNull()) leg->AddEntry(h,text.Data(),"l");

  TString outfileName = Grid+"_contours.root" ;
  TString histname = h->GetName();
  if(!outfile) outfile = new TFile(outfileName, "recreate");
  TGraph* g = (TGraph*) ContourGraph( h )->Clone("g"+histname);
  if( histname!="contour_obscls_1"&&histname!="contour_obscls_2" ){
    outfile->cd();
    g->Write();
    h->Write();
  }

}


void
DrawContourLine3sigma( TLegend *leg, TH2F* hist, const TString& text="", Int_t linecolor=CombinationGlob::c_VDarkGray, Int_t linestyle=2, Int_t linewidth=2 )
{
  // contour plot
  TH2F* h = new TH2F( *hist );
  h->SetContour( 1 );
  double pval = (1.-0.9973)*0.5; // one-sided
  double signif = TMath::NormQuantile(1-pval);
  cout <<"DrawContourLine3sigma: pval="<<pval<<", "<<signif<<"sigma for "<<text<<endl;
  h->SetContourLevel( 0, signif );

  h->SetLineColor( linecolor );
  h->SetLineWidth( linewidth );
  h->SetLineStyle( linestyle );
  h->Draw( "samecont3" );

  if (!text.IsNull()) leg->AddEntry(h,text.Data(),"l");
}

void
DrawContourLine2sigma( TLegend *leg, TH2F* hist, const TString& text="", Int_t linecolor=CombinationGlob::c_VDarkGray, Int_t linestyle=2, Int_t linewidth=2 )
{
  // contour plot
  TH2F* h = new TH2F( *hist );
  h->SetContour( 1 );
  double pval = (1.-0.9545)*0.5; // one-sided
  double signif = TMath::NormQuantile(1-pval);
  cout <<"DrawContourLine3sigma: pval="<<pval<<", "<<signif<<"sigma for "<<text<<endl;
  h->SetContourLevel( 0, signif );

  h->SetLineColor( linecolor );
  h->SetLineWidth( linewidth );
  h->SetLineStyle( linestyle );
  h->Draw( "samecont3" );

  if (!text.IsNull()) leg->AddEntry(h,text.Data(),"l");
}

void
DrawContourLine99( TLegend *leg, TH2F* hist, const TString& text="", Int_t linecolor=CombinationGlob::c_VDarkGray, Int_t linestyle=2, Int_t linewidth=2 )
{
  // contour plot
  TH2F* h = new TH2F( *hist );
  h->SetContour( 1 );
  double pval = CombinationGlob::cl_percent[2];
  double signif = TMath::NormQuantile(1-pval);

  h->SetContourLevel( 0, signif );

  h->SetLineColor( linecolor );
  h->SetLineWidth( linewidth );
  h->SetLineStyle( linestyle );
  h->Draw( "samecont3" );

  if (!text.IsNull()) leg->AddEntry(h,text.Data(),"l");
}


void
DrawContourLine68( TLegend *leg, TH2F* hist, const TString& text="", Int_t linecolor=CombinationGlob::c_VDarkGray, Int_t linestyle=2 )
{
  // contour plot
  TH2F* h = new TH2F( *hist );
  h->SetContour( 1 );
  double pval = CombinationGlob::cl_percent[0];
  double signif = TMath::NormQuantile(1-pval);

  h->SetContourLevel( 0, signif );

  h->SetLineColor( linecolor );
  h->SetLineWidth( 2 );
  h->SetLineStyle( linestyle );
  h->Draw( "samecont3" );

  if (!text.IsNull()) leg->AddEntry(h,text.Data(),"l");
}

TH2F* linearsmooth(const TH2& hist, const char* name, const char* title) {
  int nbinsx = hist.GetNbinsX();
  int nbinsy = hist.GetNbinsY();

  double xbinwidth = ( hist.GetXaxis()->GetBinCenter(nbinsx) - hist.GetXaxis()->GetBinCenter(1) ) / double(nbinsx-1);
  double ybinwidth = ( hist.GetYaxis()->GetBinCenter(nbinsy) - hist.GetYaxis()->GetBinCenter(1) ) / double(nbinsy-1);

  int nbinsxsm = 2*nbinsx - 1 ;
  int nbinsysm = 2*nbinsy - 1 ;

  double xmin = hist.GetXaxis()->GetBinCenter(1) - xbinwidth/4. ;
  double xmax = hist.GetXaxis()->GetBinCenter(nbinsx) + xbinwidth/4. ;
  double ymin = hist.GetYaxis()->GetBinCenter(1) - ybinwidth/4. ;
  double ymax = hist.GetYaxis()->GetBinCenter(nbinsy) + ybinwidth/4. ;

  TH2F* hist2 = new TH2F(name, title, nbinsxsm, xmin, xmax, nbinsysm, ymin, ymax);

  for (Int_t ibin1=1; ibin1 < hist.GetNbinsX(); ibin1++) {
    for (Int_t ibin2=1; ibin2 < hist.GetNbinsY(); ibin2++) {
      float f00 = hist.GetBinContent(ibin1,ibin2);
      float f10 = hist.GetBinContent(ibin1+1,ibin2);
      float f01 = hist.GetBinContent(ibin1,ibin2+1);
      float f11 = hist.GetBinContent(ibin1+1,ibin2+1);

      for (Int_t i=0; i<=2; ++i)
        for (Int_t j=0; j<=2; ++j) {
          float x = i*0.5; float y = j*0.5;
          float val = (1-x)*(1-y)*f00 + x*(1-y)*f10 + (1-x)*y*f01 + x*y*f11 ;
          Int_t jbin1 = 2*ibin1 - 1 + i;
          Int_t jbin2 = 2*ibin2 - 1 + j;
          hist2->SetBinContent(jbin1,jbin2,val);
        }
    }
  }

  return hist2; // caller owns histogram
}


TString GetSRName(int fID, TString txtfile){

  TString text="non";
  /*
  //TString SRABCSets[10]={"2jl","2jc","2jt","4jt","5j","6jm", "6jt","no","no","no"}; //bis
  //TString SRABCSets[10]={"6jm", "2jt", "4jt", "2jl", "2jm", "5j", "6jt","no","no","no"}; 
  TString SRABCSets[10]={"2jl","2jm","2jt","4jt","5j","6jm", "6jt","no","no","no"}; //bis
  if( fID>0 && fID<10 )  text = SRABCSets[fID-1];
  */
  TString infoFileName = txtfile + "_infoFile";
  std::ifstream ifs(infoFileName);
  if( !ifs ){
    std::cout<<" File open error!! : "<<infoFileName<<std::endl;
    std::cout<<" Could not get SR name!!"<<std::endl;
    return text;
  }
  while(!ifs.eof()){
    TString colon, SRName;
    int  index;
    ifs>>index>>colon>>SRName;
    if( index == fID ){
      text = SRName.ReplaceAll("SR","");
      break;
    }
  }
  ifs.close();

  return text;
}


void Show_SR(TString oredList,  TCanvas *can, TH1* frame, float xlow, float xhigh, float ylow, float yhigh, TString Grid)
{
  std::stringstream ss; TString str;
  Int_t c_myRed      = TColor::GetColor("#aa000");

  can->cd();

  TLatex lat;
  //lat.SetTextAlign( 11 );
  lat.SetTextSize( 0.0265 );
  lat.SetTextColor( 12 );
  lat.SetTextFont( 42 );

  cout << "Draw signal region labels." << endl;
  //gROOT->ProcessLine(".L summary_harvest_tree_description.h+");
  gSystem->Load("libSusyFitter.so");

  TString txtfile=oredList;
  txtfile.ReplaceAll(".root","");

  TTree* tree = harvesttree( txtfile!=0 ? txtfile : "" );
  if (tree==0) { 
    cout << "Cannot open list file. Exit." << endl;
    return;
  }

  Char_t fID;
  Float_t m0; 
  Float_t m12; 

  TBranch *b_m0;
  TBranch *b_m12;
  TBranch *b_fID;

  TString m_x = "m0";
  TString m_y = "m12";
  if(Grid=="GG_onestepCC"){
    m_x = "mgluino";
    m_y = "mlsp";
  }else if(Grid=="SS_onestepCC"){
    m_x = "msquark";
    m_y = "mlsp";
  }else if (Grid=="SS_direct" || Grid=="GG_direct"){
    m_x = "m0";
    m_y = "m12";
  }else if (Grid=="SM_GG_N2"){
    m_x = "mgluino";
    m_y = "mlsp2";
  }

  tree->SetBranchAddress(m_x, &m0, &b_m0);
  tree->SetBranchAddress(m_y, &m12, &b_m12);
  tree->SetBranchAddress("fID",  &fID,  &b_fID);

  for( Int_t i = 0; i < tree->GetEntries(); i++ ){

    tree->GetEntry( i );


    int _m0 = (int) m0;
    int _m12 = (int) m12;

    int fid = std::atoi((TString)fID);
    TString mySR = GetSRName(fid,txtfile);
    cout <<"BestSR for "<< m0 << " " << m12 << " is: " << fID <<" "<<mySR<<" xmax="<<frame->GetXaxis()->GetXmax()<< endl;
    // be 10% outside the edges
    //if((_m0 > (xhigh-xlow)/30.0 + xlow) && (_m12 < yhigh - (yhigh-ylow)/30.0) && _m12<870 && _m0<1980. && _m12!=60)
    //{
    if( (_m0 > (xhigh-xlow)/30.0 + xlow) && (_m12 < yhigh - (yhigh-ylow)/30.0) && (m0<frame->GetXaxis()->GetXmax()) ){
      cout<<"draw"<<endl;
      lat.SetTextSize( 0.0265 );
      lat.DrawLatex(m0-25, m12+10, mySR.Data());
      lat.SetTextSize( 0.02 );
      ss.str(""); ss<<"("<<m0<<","<<m12<<")"; str=ss.str();
      //lat.DrawLatex(m0, m12, str.Data());
    }

    //}
  }
}



void SUSY_contourplots(
    TString fname0="", TString fname1="", TString fname2="", 
    const char* prefix="",
    TString lumi = 5,
    TString Grid="GG_direct",
    bool showSR=false,
    int discexcl = 1)
{

  initialize();
  cout<<"Grid = "<<Grid<<endl;

  //set style and remove existing canvas'
  CombinationGlob::Initialize();

  TString yMass="mLSP";
  TString yParticleTex="m_{#tilde{#chi}_{1}^{0}}";
  if( Grid=="SM_GG_N2" ){
    yMass="m2ndLSP";
    yParticleTex="m_{#tilde{#chi}_{2}^{0}}";
  }

  cout << "--- Plotting mGluino versus "+yMass+" " << endl;

  // Open files and retrieve histogram
  TFile* f0;
  TFile* f1;
  TFile* f2;

  TString dirname=lumi+"ifb";

  cout << "--- Reading root base file0: " << fname0 << endl;
  f0 = TFile::Open( fname0, "READ" );
  f0->ls();
  cout << "--- Reading root base file1: " << fname1 << endl;
  f1 = TFile::Open( fname1, "READ" );
  f1->ls();
  cout << "--- Reading root base file2: " << fname2 << endl;
  f2 = TFile::Open( fname2, "READ" );
  f2->ls();

  if(!f0 || !f1 || !f2) cout << "Cannot open!"<< endl;

  // Which variable to plot?
  TString disc_p0exp = "sigp1expclsf";
  TString disc_p1obs = "sigp1clsf";

  // hist for best SR contour expected
  TH2F* histecls0 = (TH2F*)f0->Get(disc_p0exp);
  // place holder for xsec +/-1 lines
  TH2F* histecls1 = (TH2F*)f1->Get(disc_p1obs);  
  TH2F* histecls2 = (TH2F*)f2->Get(disc_p1obs);
  TH2F* histecls0zz= (TH2F*)f0->Get(disc_p1obs);

  if(doSmooth){
    histecls0->Smooth();
    histecls1->Smooth();
    histecls2->Smooth();
    histecls0zz->Smooth();
  }

  TH2F* contourobs_comb(0);
  if (histecls0!=0) { contourobs_comb     = FixAndSetBorders( *histecls0, "contourobs_comb", "contourobs_comb", 0 ); }

  TH2F* hist0_1su(0);
  TH2F* hist0_1sd(0);
  hist0_1su = (TH2F*)f0->Get( "sigclsu1s" );
  if(!hist0_1su){
    std::cout<<"Error!! Failed to get sigclsu1s from "<<f0->GetName()<<std::endl;
    exit(1);
  }
  hist0_1sd = (TH2F*)f0->Get( "sigclsd1s" );
  if(!hist0_1sd){
    std::cout<<"Error!! Failed to get sigclsd1s from "<<f0->GetName()<<std::endl;
    exit(1);
  }

  if(doSmooth){
    hist0_1su->Smooth();
    hist0_1sd->Smooth();
  }

  cout << "--- Retrieveing TGraph from TH2D : " << hist0_1su->GetName() << endl;
  TGraph* gr_contour_1su = (TGraph*) ContourGraph( hist0_1su )->Clone();
  cout << "--- Retrieveing TGraph from TH2D : " << hist0_1sd->GetName() << endl;
  TGraph* gr_contour_1sd = (TGraph*) ContourGraph( hist0_1sd )->Clone();

  cout << "--- FixAndSetBorders : " << hist0_1su->GetName() << endl;
  TH2F* contour_1su(0);
  if (hist0_1su!=0) { contour_1su     = FixAndSetBorders( *hist0_1su, "contour_1su", "contour_1su", 0 ); }
  cout << "--- FixAndSetBorders : " << hist0_1sd->GetName() << endl;
  TH2F* contour_1sd(0);
  if (hist0_1sd!=0) { contour_1sd     = FixAndSetBorders( *hist0_1sd, "contour_1sd", "contour_1sd", 0 ); }     

  gStyle->SetPaintTextFormat(".2g");

  // --- draw
  cout << "--- Drawing " << endl;
  // Create canvas
  TCanvas* c = new TCanvas( "c", "A scan of m_#tilde{g} versus "+yParticleTex, 0, 0, 
      CombinationGlob::StandardCanvas[0], CombinationGlob::StandardCanvas[1] );

  cout << "--- Set & Draw frame histogram " << endl;
  // Create and draw the frame
  float frameXmin=200, frameXmax=2000;
  float frameYmin=0  , frameYmax=1400;
  if( Grid=="SS_direct" || Grid=="SS_onestepCC" ){
    frameXmin=200.; frameXmax=1400.;
    frameYmin=0.  ; frameYmax=1200.;
  }else if( Grid=="GG_direct" || Grid=="GG_onestepCC" ){
    frameXmin=200.; frameXmax=2000.;
    frameYmin=0.  ; frameYmax=1400.;
  }else if( Grid=="SM_GG_N2" ){
    frameXmin=600.; frameXmax=1800.;
    frameYmin=100.; frameYmax=1600.;
  }
  TH2F *frame = new TH2F("frame", "m_#tilde{g} vs "+yParticleTex+" - ATLAS",
      180, frameXmin, frameXmax, 200, frameYmin, frameYmax );

  // Set common frame style
  gPad->SetTopMargin( 0.07  );
  gPad->SetBottomMargin( 0.120  );
  gPad->SetRightMargin( 0.12 );
  gPad->SetLeftMargin( 0.1  );

  //Palette
  TString STmass="";
  if(Grid=="GG_direct" || Grid=="GG_onestepCC" || Grid=="SM_GG_N2" ){
    STmass = "m_{#tilde{g}}";
  }else if (Grid=="SS_direct"||Grid=="SS_onestepCC" ){
    STmass = "m_{#tilde{q}}";
  }

  frame->SetXTitle( STmass+" [GeV]" );
  frame->SetYTitle( yParticleTex+" [GeV]" );
  frame->SetZTitle( "X-Section" );
  frame->GetXaxis()->SetTitleOffset(1.15);
  frame->GetYaxis()->SetTitleOffset(1.15);
  frame->GetZaxis()->SetTitleOffset(1);

  frame->GetXaxis()->SetTitleFont( 42 );
  frame->GetYaxis()->SetTitleFont( 42 );
  frame->GetXaxis()->SetLabelFont( 42 );
  frame->GetYaxis()->SetLabelFont( 42 );

  frame->GetXaxis()->SetTitleSize( 0.04 );
  frame->GetYaxis()->SetTitleSize( 0.04 );
  frame->GetXaxis()->SetLabelSize( 0.035 );
  frame->GetYaxis()->SetLabelSize( 0.035 );
  frame->GetZaxis()->SetLabelSize( 0.015 );

  frame->Draw("axis same");

  // creat legend
  cout << "--- Create legend " << endl;
  TLegend *leg = new TLegend(0.45,0.72,0.7,0.9);
  leg->SetTextSize( CombinationGlob::DescriptionTextSize );
  leg->SetFillStyle(0000); 
  leg->SetTextSize( 0.03 );
  leg->SetTextFont( 42 );

  Int_t c_myYellow   = TColor::GetColor("#ffe938"); 
  Int_t c_myRed      = TColor::GetColor("#aa000");
  Int_t c_myExp      = kBlue+2; //TColor::GetColor("#28373c");

  // color code for colz
  const Int_t ncontours=99;
  const Int_t NRGBs=4;
  Double_t stops[NRGBs] = {0.00, 0.33, 0.66, 1.00};
  Double_t red[NRGBs]   = {1.00, 238./255., 139./255., 0.00};
  Double_t green[NRGBs] = {1.00, 201./255., 90./255., 0.00};
  Double_t blue[NRGBs]  = {1.00, 0.00, 0.00, 0.00};

  TColor::CreateGradientColorTable(NRGBs, stops, red, green, blue, ncontours);
  gStyle->SetNumberContours(ncontours);

  // plot p0 map in 2D 
  //contourobs_comb->Draw("colz same");
  TLatex latexz=TLatex();
  latexz.SetTextSize(0.035);
  latexz.SetTextFont( 42 );
  latexz.SetTextAngle(90.);
  //contourobs_comb->GetZaxis()->SetRangeUser(0.0, 7);
  //latexz.DrawText(2200, 20,"CL_s with best SR");

  TGraph *LEPchar = new TGraph(6);
  TGraph *targetpoint = new TGraph(3);
  TGraph *targetpoint_white = new TGraph(3);
  if (Grid=="GG_direct"){
    LEPchar->SetPoint(0,197.5,0);
    if(lumi=="8"){
      LEPchar->SetPoint(1,995,0);
    }else{
      LEPchar->SetPoint(1,1195,0);
    }
    LEPchar->SetPoint(2,650.,630.);
    LEPchar->SetPoint(3,630.,630.);
    LEPchar->SetPoint(4,197.5,197.5);
    LEPchar->SetPoint(5,197.5,0.);
    targetpoint->SetPoint(1,1100,500+20);
    targetpoint->SetPoint(2,750,650+20);
    targetpoint_white->SetPoint(1,1100,500+20);
    targetpoint_white->SetPoint(2,750,650+20);
    if(lumi=="8"){
      targetpoint->SetPoint(0,1400,0+20);
      targetpoint_white->SetPoint(0,1400,0+20);
    }else{
      targetpoint->SetPoint(0,1400,0+20);
      targetpoint_white->SetPoint(0,1400,0+20);
    }
  }else if(Grid=="SS_direct"){
    LEPchar->SetPoint(0,197.5,0);
    LEPchar->SetPoint(1,810,0);
    LEPchar->SetPoint(2,430.,430.);
    LEPchar->SetPoint(3,197.5,197.5);
    LEPchar->SetPoint(4,197.5,0.);     
    if(lumi=="8"){
      targetpoint->SetPoint(0,1200,0+20);
      targetpoint_white->SetPoint(0,1200,0+20);
    }else{
      targetpoint->SetPoint(0,1000,0+20);
      targetpoint_white->SetPoint(0,1000,0+20);
    }     
    targetpoint->SetPoint(1,800,400+20);
    targetpoint->SetPoint(2,425,375+20);
    targetpoint_white->SetPoint(1,800,400+20);
    targetpoint_white->SetPoint(2,425,375+20);
  }else if (Grid=="GG_onestepCC"){
    LEPchar->SetPoint(0,197.5,0);
    LEPchar->SetPoint(1,1195,0);
    LEPchar->SetPoint(3,400.,375.);
    LEPchar->SetPoint(2,400.,400.);
    LEPchar->SetPoint(4,197.5,197.5);
    LEPchar->SetPoint(5,197.5,0.);
    targetpoint->SetPoint(0,1545,25);
    targetpoint->SetPoint(1,1265,625);
    targetpoint->SetPoint(2,825,745);
    targetpoint_white->SetPoint(0,1545,25);
    targetpoint_white->SetPoint(1,1265,625);
    targetpoint_white->SetPoint(2,825,745);
  }

  cout << "--- Get observed limit errors " << endl;
  TH2F* histe_esigxsp1s;                              
  TH2F* histe_esigxsm1s;      
  if(f1) histe_esigxsp1s = (TH2F*)f1->Get( "sigp1clsf" ); 
  if(f2) histe_esigxsm1s = (TH2F*)f2->Get( "sigp1clsf" );
  if(doSmooth){
    histe_esigxsp1s->Smooth();
    histe_esigxsm1s->Smooth();
  }

  cout << "--- FixAndSetBorders expected band : " << histe_esigxsp1s->GetName()<< endl;
  TH2F* contour_esigxsp1s
    = ( histe_esigxsp1s!=0 ? FixAndSetBorders( *histe_esigxsp1s, "contour_esigxsp1s", "contour_esigxsp1s", 0 ) : 0);                              
  cout << "--- FixAndSetBorders expected band : " << histe_esigxsm1s->GetName()<< endl;
  TH2F* contour_esigxsm1s                              
    = ( histe_esigxsm1s!=0 ? FixAndSetBorders( *histe_esigxsm1s, "contour_esigxsm1s", "contour_esigxsm1s", 0 ) : 0);      

  cout << "--- FixAndSetBorders expected band : " << histecls1->GetName()<< endl;
  TH2F* contour_obscls_1(0);
  if (histecls1!=0) { contour_obscls_1     = FixAndSetBorders( *histecls1, "contour_obscls_1", "contour_obscls_1", 0 ); }   
  TH2F* contour_obscls_2(0);
  cout << "--- FixAndSetBorders expected band : " << histecls2->GetName()<< endl;
  if (histecls2!=0) { contour_obscls_2     = FixAndSetBorders( *histecls2, "contour_obscls_2", "contour_obscls_2", 0 ); }   
  TH2F* contour_obscls_0(0);
  cout << "--- FixAndSetBorders expected band : " << histecls0zz->GetName()<< endl;
  histecls0zz->Print();
  if (histecls0zz!=0) { contour_obscls_0     = FixAndSetBorders( *histecls0zz, "contour_obscls_0", "contour_obscls_0", 0 ); }   

  cout << "--- Draw expected band " << endl;
  c->cd();
  TGraph* grshadeExp =  (TGraph*) DrawExpectedBand( gr_contour_1su, gr_contour_1sd,   c_myYellow , 1001   , 0 )->Clone();
  c->cd();
  DrawContourLine95( leg, contour_1su,         "", c_myYellow, 1, 2 , Grid );
  c->cd();
  DrawContourLine95( leg, contour_1sd,         "", c_myYellow, 1, 2 , Grid );

  c->cd();
  if (contour_esigxsp1s!=0) DrawContourLine95( leg, contour_esigxsp1s, "", CombinationGlob::c_DarkRed, 3, 2 , Grid );
  c->cd();
  if (contour_esigxsm1s!=0) DrawContourLine95( leg, contour_esigxsm1s, "", CombinationGlob::c_DarkRed, 3, 2 , Grid );

  c->cd();
  if (contour_obscls_1!=0) DrawContourLine95( leg, contour_obscls_1, ""              , CombinationGlob::c_DarkRed, 3, 2 , Grid ); 
  c->cd();
  if (contour_obscls_0!=0) DrawContourLine95( leg, contour_obscls_0, "Observed limit (#pm1 #sigma_{theory}^{SUSY})", CombinationGlob::c_DarkRed, 1, 4 , Grid );
  c->cd();
  if (contour_obscls_2!=0) DrawContourLine95( leg, contour_obscls_2, ""              , CombinationGlob::c_DarkRed, 3, 2 , Grid ); 



  c->cd();
  DrawContourLine95( leg, contourobs_comb, "", c_myExp, 6, 2 , Grid );

  c->cd();
  DummyLegendExpected(leg, "Exp. limits (#pm1 #sigma_{exp})",  c_myYellow, 1001, c_myExp, 6, 2);

  // plot 8 TeV exclusion:
  cout << "--- Get 8 TeV exclusionend " << endl;
  TGraphAsymmErrors *g(0);
  if(Grid=="GG_direct"){
    g=GG_direct_8TeVobs();
  }else if (Grid=="SS_direct"){
    g=SS_direct_8TeVobs();
  }else if (Grid=="SS_onestepCC"){
    g=SS_onestepCC_8TeVobs();
  }else if (Grid=="GG_onestepCC"){
    g=GG_onestepCCx12_8TeVobs();
  }
  c->cd();
  if(g){
    cout << "--- Draw graph : " << g->GetName()<< endl;
    g->SetName("gRun1");
    g->SetLineStyle(1);

    //g->SetFillColor(kBlue-10);
    //g->SetLineWidth(1);
    //g->SetFillStyle(1001);
    g->SetFillColor(kBlue-7);
    g->SetLineWidth(2);
    g->SetFillStyle(3490);

    g->SetLineColor(17);
    g->Draw("F same");
    g->Draw("L same");
    leg->AddEntry(g,"Observed limit (20.3 fb^{-1}, 8 TeV)","f");
    TString outfileName = Grid+"_contours.root" ;
    if(!outfile) outfile = new TFile(outfileName, "recreate");
    outfile->cd();
    g->Write();
  }

  c->cd();
  // uncertainty lines in observed limit legend
  TLine* lineObsLimitUnc = new TLine();
  int nLegEntry = leg->GetNRows();
  float legX1=leg->GetX1();
  float legX2=leg->GetX2();
  float legY1=leg->GetY1();
  float legY2=leg->GetY2();
  float lineY =legY2-(legY2-legY1)*0.5/(float)nLegEntry;
  float deltaY=(legY2-legY1)*0.2/(float)nLegEntry;
  float marginX=(legX2-legX1) * leg->GetMargin();
  float Xspace =marginX*0.15;
  cout<<"nLegEntry="<<nLegEntry<<endl;
  cout<<"leg X="<<legX1<<"--"<<legX2<<endl;
  cout<<"leg Y="<<legY1<<"--"<<legY2<<endl;
  cout<<"marginX="<<marginX<<endl;

  cout<<"line Y ="<<lineY<<endl;
  cout<<"deleta leg Y="<<deltaY<<endl;
  lineObsLimitUnc->SetLineStyle(3);
  lineObsLimitUnc->SetLineWidth(1);
  lineObsLimitUnc->SetLineColor(CombinationGlob::c_DarkRed);
  lineObsLimitUnc->DrawLineNDC(legX1+Xspace, lineY+deltaY, legX1+marginX-Xspace, lineY+deltaY ) ;                
  lineObsLimitUnc->DrawLineNDC(legX1+Xspace, lineY-deltaY, legX1+marginX-Xspace, lineY-deltaY ) ;                
  lineObsLimitUnc->DrawLine(0,0.5,1,0.5) ;                

  LEPchar->SetFillColor(17);
  //LEPchar->Draw("FL same");

  targetpoint->SetMarkerSize(1.5);
  targetpoint->SetMarkerStyle(29);
  targetpoint->Draw("P same");

  targetpoint_white->SetMarkerSize(1.5);
  targetpoint_white->SetMarkerStyle(30);
  targetpoint_white->SetMarkerColor(0);
  targetpoint_white->Draw("P same");

  TObjArray* arr = fname0.Tokenize("/");
  TObjString* objstring = (TObjString*)arr->At( arr->GetEntries()-1 );
  TString outfile = objstring->GetString().ReplaceAll(".root","").ReplaceAll("_1_harvest_list","");

  // mass forbidden line
  TLine lineExcl;
  int maxframeMin=TMath::Max(frameXmin,frameYmin);
  int minframeMax=TMath::Min(frameXmax,frameYmax);
  if( Grid=="SM_GG_N2" ){
    lineExcl = ( TLine(maxframeMin,maxframeMin,minframeMax,minframeMax));
  }else{
    lineExcl = ( TLine(maxframeMin,maxframeMin,800,800));
  }
  lineExcl.SetLineStyle(9);
  lineExcl.SetLineWidth(1);
  lineExcl.SetLineColor(14);
  lineExcl.Draw("same") ;                

  // mass forbidden label
  int massforbiddenX=300;
  int massforbiddenY=380;
  if( Grid=="SM_GG_N2" ){
    massforbiddenX=700;
    massforbiddenY=750;
  }
  TLatex massforbidden = TLatex(massforbiddenX,massforbiddenY, STmass+" < "+yParticleTex);
  massforbidden.SetTextSize(0.032);
  massforbidden.SetTextColor(14);
  float angle=45.;
  if     (Grid=="SS_direct") angle=40;
  else if(Grid=="SM_GG_N2" ) angle=33;
  massforbidden.SetTextAngle(angle);
  massforbidden.SetTextFont(42);
  massforbidden.Draw("same"); 

  // Cosmetics for plotting 
  Float_t textSizeOffset = +0.000;
  Double_t xmax = frame->GetXaxis()->GetXmax();
  Double_t xmin = frame->GetXaxis()->GetXmin();
  Double_t ymax = frame->GetYaxis()->GetXmax();
  Double_t ymin = frame->GetYaxis()->GetXmin();
  Double_t dx   = xmax - xmin;
  Double_t dy   = ymax - ymin;

  TLatex *Leg0 = new TLatex( xmin, ymax + dy*0.025, "" );
  Leg0->SetTextAlign( 11 );
  Leg0->SetTextFont( 42 );
  Leg0->SetTextSize( CombinationGlob::DescriptionTextSize);
  Leg0->SetTextColor( 1 );
  Leg0->AppendPad();

  TString STdecayLabel="";
  if (Grid=="GG_direct"){
    STdecayLabel="#tilde{g}#tilde{g} production, #it{B}(#tilde{g} #rightarrow qq #tilde{#chi}_{1}^{0})=100%";
  }else if (Grid=="SS_direct"){
    STdecayLabel="#tilde{q}#tilde{q} production, #it{B}(#tilde{q} #rightarrow q #tilde{#chi}_{1}^{0})=100%";
  }else if (Grid=="SS_onestepCC"){
    STdecayLabel="#tilde{q}#tilde{q} production, #it{B}(#tilde{q} #rightarrow q #tilde{#chi}_{1}^{#pm} #rightarrow q W^{#pm} #tilde{#chi}_{1}^{0})=100%, m(#tilde{#chi}_{1}^{#pm})=(m(#tilde{q}) + m(#tilde{#chi}_{1}^{0}))/2";
  }else if (Grid=="GG_onestepCC"){
    STdecayLabel="#tilde{g}#tilde{g} production, #it{B}(#tilde{g} #rightarrow qq #tilde{#chi}_{1}^{#pm} #rightarrow qq W^{#pm} #tilde{#chi}_{1}^{0})=100%, m(#tilde{#chi}_{1}^{#pm})=(m(#tilde{g}) + m(#tilde{#chi}_{1}^{0}))/2";
  }else if (Grid=="SM_GG_N2"){
    STdecayLabel="#tilde{g}#tilde{g} production, #it{B}(#tilde{g} #rightarrow qq #tilde{#chi}_{2}^{0} #rightarrow qq Z #tilde{#chi}_{1}^{0})=100%, m(#tilde{#chi}_{1}^{0})=1 GeV";
  }
  TLatex* decayLabel = new TLatex();
  decayLabel->SetNDC();
  decayLabel->SetTextFont(42);
  decayLabel->SetTextColor(EColor::kBlack);
  decayLabel->SetTextSize( 0.0335 );
  decayLabel->DrawLatex(0.14, 0.962,STdecayLabel);

  TLatex* atlasLabel = new TLatex();
  atlasLabel->SetNDC();
  atlasLabel->SetTextFont(42);
  atlasLabel->SetTextColor(EColor::kBlack);
  atlasLabel->SetTextSize( 0.03 );
  atlasLabel->DrawLatex(0.13, 0.87,"#bf{#it{ATLAS}}");
  atlasLabel->AppendPad();

  TLatex* progressLabel = new TLatex();
  progressLabel->SetNDC();
  progressLabel->SetTextFont(42);
  progressLabel->SetTextColor(EColor::kBlack);
  progressLabel->SetTextSize( 0.03 );
  progressLabel->DrawLatex(0.2, 0.87,"Internal");
  progressLabel->AppendPad();

  TLatex *Leg1 = new TLatex();
  Leg1->SetNDC();
  Leg1->SetTextFont( 42 );
  Leg1->SetTextSize( 0.03 );
  Leg1->SetTextColor( EColor::kBlack );
  Leg1->DrawLatex(0.13, 0.79, "#int Ldt = "+lumi+" fb^{-1}, #sqrt{s} = 13 TeV");
  Leg1->AppendPad();

  TLatex *Leg2 = new TLatex();
  Leg2->SetNDC();
  Leg2->SetTextSize(0.03);
  Leg2->SetTextColor( 1 );
  Leg2->SetTextFont( 42 );
  Leg2->DrawLatex(0.13, 0.7, prefix);
  if (prefix!=0) { Leg2->AppendPad(); }

  TLatex *Leg3 = new TLatex();
  Leg3->SetNDC();
  Leg3->SetTextFont( 42 );
  Leg3->SetTextSize( 0.03 );
  Leg3->SetTextColor( EColor::kBlack );
  Leg3->DrawLatex(0.13, 0.6, "All limits at 95% CL.");
  Leg3->AppendPad();

  TLatex *Leg4 = new TLatex();
  Leg4->SetNDC();
  Leg4->SetTextFont( 42 );
  Leg4->SetTextSize( 0.03 );
  Leg4->SetTextColor( EColor::kBlack );
  Leg4->DrawLatex(0.13, 0.65, "(Fit to SR,CRT,CRW,CRY)");
  Leg4->AppendPad();

  if (prefix!=0) { Leg2->AppendPad(); }

  if(showSR){
    std::cout << "--- printing best SRs" << std::endl;
    Show_SR(fname0, c, frame, xmin, xmax, ymin, ymax, Grid);
    TLatex lat;
    //lat.SetTextAlign( 11 );
    lat.SetTextSize( 0.0265 );
    lat.SetTextColor( 12 );
    lat.SetTextFont( 42 ); 
  }

  frame->Draw("sameaxis"); 
  leg->Draw("same");

  c->Update();
  //TString plotname = "plots/"+lumi+"ifb/atlasCLs_"+Grid+".eps";
  //if (showSR) plotname = "plots/"+lumi+"ifb/atlasCLs_"+Grid+"_showSR.eps"; 
  TString plotname = "plots/atlasCLs_"+Grid+".eps";
  if (showSR) plotname = "plots/atlasCLs_"+Grid+"_showSR.eps"; 
  c->SaveAs(plotname);
  c->SaveAs(plotname.ReplaceAll(".eps",".pdf"));


}


